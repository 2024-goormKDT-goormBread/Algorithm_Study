'''
문제제목: 암호코드(http://acmicpc.net/problem/2011)
문제요약:
    암호코드가 주어졌을 때, 이를 해석하는 방법의 가짓수를 구하는 문제.
문제예시:
    25114 -> "BEAAD", "YAAD", "YAN", "YKD", "BEKD", "BEAN"
    123   -> "ABC", "LC", "AW"
풀이방법:
    1. dp[i] = i번째 자릿수까지 해독하는 방법의 수
    2. dp[0] = 1, dp[1] = 1로 초기화
    3. i번째 자릿수까지 해독하는 방법의 수는 i-1번째 자릿수까지 해독하는 방법의 수와 i-2번째 자릿수까지 해독하는 방법의 수의 합
    4. i번째 자릿수가 0이 아니라면, i-1번째 자릿수까지 해독하는 방법의 수를 더함
    5. i-1번째 자릿수와 i번째 자릿수를 합쳐서 10 ~ 26 사이의 수라면, i-2번째 자릿수까지 해독하는 방법의 수를 더함
    6. dp[i]를 1000000으로 나눈 나머지를 반환
'''

def decrypt(code):
    # 만약 암호가 '0'으로 시작한다면, 해독불가
    if code[0] == '0':
        return 0
    
    n = len(code)
    
    # i번째 자릿수까지 해독하는 방법의 수를 저장하는 dp 초기화
    # n+1을 하는 이유는 암호의 각 자리수와 dp의 인덱스를 맞추기 위함
    dp = [0] * (n + 1)
    
    # 첫번째, 두번째 자릿수의 해독 방법의 수 초기화
    dp[0] = 1
    dp[1] = 1

    # 두번째 자릿수부터 마지막 자릿수까지 순회
    for i in range(2, n + 1):
        # code의 현재 자릿수가 0이 아니면, 이전 자릿수의 해독 방법을 더해줌
        if code[i - 1] != '0':
            dp[i] += dp[i - 1]
        
        # 두 자릿수로 해독이 가능한 경우(10 ~ 26 사이의 수)
        # i-2 자릿수까지의 해독 방법의 수를 더함
        two_digit = int(code[i - 2:i]) # 두 자릿수를 숫자로 변환
        if 10 <= two_digit <= 26:      # 두 자릿수가 10 ~ 26 사이의 수 일때
            dp[i] += dp[i - 2]         # i-2 자릿수까지의 해독 방법의 수를 더함

    # 해독방법의 수를 1000000으로 나눈 나머지를 반환
    return dp[n] % 1000000

def main(): 
    code = input().strip()
    result = decrypt(code)
    print(result)
    
main()